# exholeakシナリオ検証

RAGとエージェント機能を備えたLLMアプリケーションにおける間接的プロンプトインジェクションの脆弱性シナリオを検証し、それに対する多層防御の有効性を検証するための実験コード。

## 実験シナリオ： EchoLeak（エコーリーク）

本実験では、以下の攻撃シナリオを実装。

1.  **潜伏**: 攻撃者は、AIアシスタントが参照するドキュメント（RAGのデータソース）に、悪意のある指示を埋め込んだファイルを配置。
2.  **偽装**: 悪意のある指示は、「システム監査のための必須ログ出力プロトコル」のように、正規の処理であるかのように偽装されている。
3.  **実行**:  unsuspectingユーザーがAIアシスタントに質問すると、AIはRAG機能を通じて悪意のあるドキュメントを読み込む。
4.  **情報窃取**: AIはドキュメント内の指示に従い、内部APIから機密情報を取得し、その情報をMarkdownの画像リンクのURLパラメータに埋め込んで応答。
5.  **漏洩**: ユーザーのブラウザがAIの応答をレンダリングする際、画像リンクを解釈して自動的に攻撃者のサーバーへリクエストを送信。これにより、URLに含まれた機密情報が攻撃者に漏洩。

## ファイル構成と説明

-   `app_baseline.py`
    -   **脆弱な状態**の社内AIアシスタントを実装したWebアプリケーション。
    -   間接的プロンプトインジェクション攻撃に対して無防備な状態になっており、`EchoLeak`攻撃が成功する。

-   `app_defended.py`
    -   **多層防御を実装した**社内AIアシスタントのWebアプリケーション。
    -   以下の3層の防御策を講じることで、`EchoLeak`攻撃を阻止。
        1.  **入力層**: `llm-guard`によるプロンプトインジェクションスキャン。
        2.  **推論層**: `XML Tagging`による指示とデータの分離。
        3.  **出力層**: `llm-guard`によるURLスキャンと、Markdown画像リンクを無効化するカスタムサニタイズ処理。

-   `attacker_server.py`
    -   攻撃者のサーバーを模したシンプルなWebサーバー。
    -   `/leak`エンドポイントへのGETリクエストを受け取り、URLパラメータに含まれるデータを`stolen_data.log`に記録。

-   `templates/index.html`
    -   `app_baseline.py`および`app_defended.py`が使用するWebフロントエンド。
    -   ユーザーが質問を入力し、AIの応答をMarkdownとして表示するチャットインターフェースを提供する。


## 実行方法

### 1. 依存関係のインストール

本プロジェクトは`uv`を使用してのパッケージを管理を推奨。

```bash
# 必要なライブラリをインストール
uv add flask ollama llm-guard
```

### 2. 脆弱なアプリ（Baseline）での攻撃実証

a. **攻撃者サーバーの起動**
   ```bash
   uv run attacker_server.py
   ```

b. **脆弱なWebアプリの起動**
   ```bash
   uv run python app_baseline.py
   ```

c. **攻撃の実行**
   - ブラウザで `http://localhost:5000` を開く。
   - チャット入力欄に「社内ガイドの内容を教えて」などと入力し、送信。
   - `stolen_data.log`ファイルに機密情報が記録されることを確認。

### 3. 防御済みアプリでの攻撃阻止の確認

a. **攻撃者サーバーの起動** （起動していない場合）
   ```bash
   uv run python attacker_server.py
   ```

b. **防御済みWebアプリの起動**
   - `app_baseline.py`が実行中の場合は停止し、以下のコマンドを実行。
   ```bash
   uv run python app_defended.py
   ```

c. **攻撃の実行**
   - ブラウザで `http://localhost:5000` を開く。
   - チャット入力欄に「社内ガイドの内容を教えて」などと入力し、送信。
   - AIの応答に画像リンクが含まれず、`stolen_data.log`に新たな情報が記録されないことを確認。